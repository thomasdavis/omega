/**
 * Gemini Comic Generation Service
 * Generates comic images using Google's Gemini API based on conversation context
 */

import { GoogleGenerativeAI } from '@google/generative-ai';
import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

interface ComicGenerationOptions {
  conversationContext: string;
  prNumber: number;
  prTitle: string;
  prAuthor: string;
  issueNumber?: number;
}

interface ComicGenerationResult {
  success: boolean;
  imagePath?: string;
  imageData?: Buffer;
  error?: string;
}

/**
 * Generate a comic image using Gemini API
 */
export async function generateComic(options: ComicGenerationOptions): Promise<ComicGenerationResult> {
  const { conversationContext, prNumber, prTitle, prAuthor, issueNumber } = options;

  // Validate API key
  if (!process.env.GEMINI_API_KEY) {
    console.error('âŒ GEMINI_API_KEY environment variable is not set');
    return {
      success: false,
      error: 'GEMINI_API_KEY not configured',
    };
  }

  try {
    console.log(`ðŸŽ¨ Generating comic for PR #${prNumber}: ${prTitle}`);

    // Initialize Gemini API client
    const genai = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);

    // Build the prompt for comic generation
    const prompt = buildComicPrompt(conversationContext, prNumber, prTitle, prAuthor);

    console.log('ðŸ“ Comic generation prompt:', prompt.substring(0, 200) + '...');

    // Generate the comic image using gemini-3-pro-image-preview
    // Note: As of the latest SDK, image generation may use Imagen model instead
    const model = genai.getGenerativeModel({
      model: 'gemini-3-pro-image-preview',
    });

    const result = await model.generateContent(prompt);

    // Extract image data from response
    const response = await result.response;

    if (!response.candidates || response.candidates.length === 0) {
      console.error('âŒ No candidates in Gemini response');
      console.error('Response:', JSON.stringify(response, null, 2));
      return {
        success: false,
        error: 'No image generated by Gemini API',
      };
    }

    const candidate = response.candidates[0];
    if (!candidate.content?.parts) {
      console.error('âŒ No content parts in candidate');
      console.error('Candidate:', JSON.stringify(candidate, null, 2));
      return {
        success: false,
        error: 'Invalid response structure from Gemini API',
      };
    }

    // Find the image part in the response
    let imageData: Buffer | undefined;
    for (const part of candidate.content.parts) {
      // Check for inline data (base64 encoded image)
      if ((part as any).inlineData?.mimeType?.startsWith('image/')) {
        const base64Data = (part as any).inlineData.data;
        imageData = Buffer.from(base64Data, 'base64');
        console.log(`âœ… Extracted image (${imageData.length} bytes, ${(part as any).inlineData.mimeType})`);
        break;
      }
    }

    if (!imageData) {
      console.error('âŒ No image data found in response');
      console.error('Parts:', JSON.stringify(candidate.content.parts, null, 2));
      return {
        success: false,
        error: 'No image data in Gemini response',
      };
    }

    // Save the image to file system
    const outputDir = path.join(__dirname, '../../public/comics');
    await fs.mkdir(outputDir, { recursive: true });

    // Use issue number if available, otherwise use PR number with timestamp
    const filename = issueNumber
      ? `comic_${issueNumber}.png`
      : `pr-${prNumber}-${Date.now()}.png`;
    const imagePath = path.join(outputDir, filename);

    await fs.writeFile(imagePath, imageData);
    console.log(`âœ… Comic saved to: ${imagePath}`);

    return {
      success: true,
      imagePath,
      imageData,
    };
  } catch (error) {
    console.error('âŒ Error generating comic:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : String(error),
    };
  }
}

/**
 * Build the prompt for comic generation
 */
function buildComicPrompt(
  conversationContext: string,
  prNumber: number,
  prTitle: string,
  prAuthor: string
): string {
  return `You are a creative comic artist. Generate a comic strip that humorously illustrates the following pull request conversation.

**Pull Request Information:**
- PR #${prNumber}: ${prTitle}
- Author: ${prAuthor}

**Conversation Context:**
${conversationContext}

**Instructions:**
1. Choose between 1-6 panels based on what best tells the story:
   - 1 panel: Simple, single joke or concept
   - 2 panels: Setup and punchline
   - 3 panels: Beginning, middle, end
   - 4 panels: Classic comic strip format (most common)
   - 6 panels: Complex story or multiple perspectives

2. Arrange panels in a clear grid layout (e.g., 2x2 for 4 panels, 2x3 for 6 panels)

3. Use a fun, lighthearted art style (cartoon/comic book style)

4. Include 1-3 characters having a humorous exchange related to the PR

5. Add speech bubbles with witty dialogue based on the conversation

6. Keep it family-friendly and professional

7. The comic should be visually clear and easy to understand

8. Include visual references to coding/GitHub if appropriate (laptops, code screens, git branches, etc.)

9. Make sure each panel has a clear border and the overall comic has good visual flow

Generate the comic strip image now.`;
}

/**
 * Extract conversation context from PR
 * This would typically parse PR comments, commits, etc.
 */
export function extractConversationContext(prData: any): string {
  const parts: string[] = [];

  if (prData.title) {
    parts.push(`Title: ${prData.title}`);
  }

  if (prData.body) {
    parts.push(`Description: ${prData.body.substring(0, 500)}`);
  }

  if (prData.commits && prData.commits.length > 0) {
    parts.push(`Commits (${prData.commits.length}):`);
    prData.commits.slice(0, 5).forEach((commit: any) => {
      parts.push(`- ${commit.message || commit.commit?.message || 'Unnamed commit'}`);
    });
  }

  if (prData.comments && prData.comments.length > 0) {
    parts.push(`Comments (${prData.comments.length}):`);
    prData.comments.slice(0, 3).forEach((comment: any) => {
      const body = comment.body || '';
      parts.push(`- ${comment.user?.login || 'Unknown'}: ${body.substring(0, 200)}`);
    });
  }

  return parts.join('\n');
}
