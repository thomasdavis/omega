/**
 * Gemini Comic Generation Service
 * Generates comic images using Google's Gemini API based on conversation context
 */

import { GoogleGenerativeAI } from '@google/generative-ai';
import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';
import { OMEGA_APPEARANCE } from '../lib/omegaAppearance.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

interface ComicGenerationOptions {
  conversationContext: string;
  prNumber: number;
  prTitle: string;
  prAuthor: string;
  issueNumber?: number;
  userIds?: string[]; // Discord user IDs for character appearance data
}

interface ComicGenerationResult {
  success: boolean;
  imagePath?: string;
  imageData?: Buffer;
  error?: string;
}

/**
 * Fetch ALL user profiles from Omega HTTP API
 * Returns the raw JSON response to dump into prompt
 */
async function fetchAllUserProfiles(): Promise<string> {
  try {
    // Determine Omega API base URL
    const OMEGA_API_URL = process.env.OMEGA_API_URL || 'https://omegaai.dev';
    const url = `${OMEGA_API_URL}/api/profiles-full`;

    console.log(`üîç Fetching ALL user profiles from ${url}`);

    const response = await fetch(url);

    if (!response.ok) {
      console.warn(`‚ö†Ô∏è Failed to fetch user profiles: ${response.status} ${response.statusText}`);
      return '';
    }

    const data = await response.json() as { success?: boolean; profiles?: Array<{ messageCount?: number; message_count?: number }> };

    if (!data.success || !data.profiles) {
      console.warn('‚ö†Ô∏è Invalid response from Omega API:', data);
      return '';
    }

    // Filter out users with messageCount = 0 (inactive users)
    const activeProfiles = data.profiles.filter((profile) => {
      const messageCount = profile.messageCount || profile.message_count || 0;
      return messageCount > 0;
    });

    console.log(`‚úÖ Fetched ${activeProfiles.length} active profiles (filtered from ${data.profiles.length} total)`);

    // Return raw JSON stringified for direct prompt insertion
    return JSON.stringify(activeProfiles, null, 2);
  } catch (error) {
    console.error('‚ùå Error fetching user profiles:', error);
    return '';
  }
}

/**
 * Generate a comic image using Gemini API
 */
export async function generateComic(options: ComicGenerationOptions): Promise<ComicGenerationResult> {
  const { conversationContext, prNumber, prTitle, prAuthor, issueNumber } = options;

  // Validate API key
  if (!process.env.GEMINI_API_KEY) {
    console.error('‚ùå GEMINI_API_KEY environment variable is not set');
    return {
      success: false,
      error: 'GEMINI_API_KEY not configured',
    };
  }

  try {
    console.log(`üé® Generating comic for PR #${prNumber}: ${prTitle}`);

    // Fetch ALL user profiles (raw JSON)
    // This gives Gemini complete context about all Discord community members
    console.log('üìä Fetching complete user profile database for comic context...');
    const profilesJson = await fetchAllUserProfiles();

    // Initialize Gemini API client
    const genai = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);

    // Build the prompt for comic generation with character data
    const prompt = buildComicPrompt(conversationContext, prNumber, prTitle, prAuthor, profilesJson);

    console.log('üìù Comic generation prompt (first 200 chars):', prompt.substring(0, 200) + '...');
    console.log('\n');
    console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
    console.log('üìù FULL COMIC GENERATION PROMPT:');
    console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
    console.log(prompt);
    console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
    console.log('\n');

    // Generate the comic image using gemini-3-pro-image-preview
    // Note: As of the latest SDK, image generation may use Imagen model instead
    const model = genai.getGenerativeModel({
      model: 'gemini-3-pro-image-preview',
    });

    const result = await model.generateContent(prompt);

    // Extract image data from response
    const response = await result.response;

    if (!response.candidates || response.candidates.length === 0) {
      console.error('‚ùå No candidates in Gemini response');
      console.error('Response:', JSON.stringify(response, null, 2));
      return {
        success: false,
        error: 'No image generated by Gemini API',
      };
    }

    const candidate = response.candidates[0];
    if (!candidate.content?.parts) {
      console.error('‚ùå No content parts in candidate');
      console.error('Candidate:', JSON.stringify(candidate, null, 2));
      return {
        success: false,
        error: 'Invalid response structure from Gemini API',
      };
    }

    // Find the image part in the response
    let imageData: Buffer | undefined;
    for (const part of candidate.content.parts) {
      // Check for inline data (base64 encoded image)
      const partWithData = part as { inlineData?: { mimeType?: string; data?: string } };
      if (partWithData.inlineData?.mimeType?.startsWith('image/')) {
        const base64Data = partWithData.inlineData.data;
        if (base64Data) {
          imageData = Buffer.from(base64Data, 'base64');
          console.log(`‚úÖ Extracted image (${imageData.length} bytes, ${partWithData.inlineData.mimeType})`);
          break;
        }
      }
    }

    if (!imageData) {
      console.error('‚ùå No image data found in response');
      console.error('Parts:', JSON.stringify(candidate.content.parts, null, 2));
      return {
        success: false,
        error: 'No image data in Gemini response',
      };
    }

    // Save the image to file system
    const outputDir = path.join(__dirname, '../../public/comics');
    await fs.mkdir(outputDir, { recursive: true });

    // Use issue number if available, otherwise use PR number with timestamp
    const filename = issueNumber
      ? `comic_${issueNumber}.png`
      : `pr-${prNumber}-${Date.now()}.png`;
    const imagePath = path.join(outputDir, filename);

    await fs.writeFile(imagePath, imageData);
    console.log(`‚úÖ Comic saved to: ${imagePath}`);

    return {
      success: true,
      imagePath,
      imageData,
    };
  } catch (error) {
    console.error('‚ùå Error generating comic:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : String(error),
    };
  }
}

/**
 * Determine optimal number of comic frames based on context complexity
 * Returns a value between 3 and 7
 */
function determineFrameCount(conversationContext: string): number {
  // Count various aspects of the conversation
  const lines = conversationContext.split('\n').filter(line => line.trim().length > 0);
  const words = conversationContext.split(/\s+/).length;
  const commentCount = (conversationContext.match(/^-\s/gm) || []).length;

  // Calculate complexity score based on multiple factors
  let complexity = 0;

  // Factor 1: Length of conversation (0-2 points)
  if (words > 500) complexity += 2;
  else if (words > 200) complexity += 1;

  // Factor 2: Number of distinct comments/commits (0-2 points)
  if (commentCount > 5) complexity += 2;
  else if (commentCount > 2) complexity += 1;

  // Factor 3: Line count (0-1 point)
  if (lines.length > 15) complexity += 1;

  // Map complexity (0-5) to frame count (3-7)
  // 0-1: 3 frames (simple)
  // 2: 4 frames
  // 3: 5 frames (moderate)
  // 4: 6 frames
  // 5+: 7 frames (complex)
  const frameCount = Math.min(7, Math.max(3, 3 + complexity));

  console.log(`üìä Frame count analysis: ${words} words, ${commentCount} comments, ${lines.length} lines ‚Üí ${complexity} complexity ‚Üí ${frameCount} frames`);

  return frameCount;
}

/**
 * Build character database section from raw JSON
 * Simply dumps the full API response into the prompt
 */
function buildCharacterDatabaseSection(profilesJson: string): string {
  if (!profilesJson || profilesJson.trim() === '') {
    return '';
  }

  return `\n\n**COMPLETE DISCORD COMMUNITY CHARACTER DATABASE (Raw JSON)**

You have access to comprehensive profiles for ALL Discord community members.
This is the COMPLETE JSON response from the /api/profiles-full endpoint.
It includes ALL psychological and phenotype data for every user:

- Physical appearance (78+ fields): hair, eyes, skin, face shape, build, height, style, etc.
- Psychological traits: Jungian archetypes, Big Five, attachment style, communication patterns
- Behavioral data: message patterns, emoji usage, sentiment, etc.
- Relational data: affinity scores, emotional bonds, Omega's thoughts about each user

**Instructions:**
- Parse this JSON to find characters mentioned in the PR conversation
- Include ALL distinct users involved in the conversation
- Use their EXACT physical descriptions for accurate character depiction
- Incorporate their psychological traits into dialogue and expressions
- The more characters involved, the richer the comic should be

**FULL DATABASE:**
\`\`\`json
${profilesJson}
\`\`\`
`;
}

/**
 * Build the prompt for comic generation
 */
function buildComicPrompt(
  conversationContext: string,
  prNumber: number,
  prTitle: string,
  prAuthor: string,
  profilesJson: string = ''
): string {
  // Filter out technical check details (type checks, lint checks, CI status, build status, etc.)
  const filteredContext = conversationContext
    .split('\n')
    .filter(line => {
      const lowerLine = line.toLowerCase();
      // Skip lines about passing checks, type errors, linting, CI status, build status
      return !(
        lowerLine.includes('type check') ||
        lowerLine.includes('lint') ||
        lowerLine.includes('linting') ||
        lowerLine.includes('eslint') ||
        lowerLine.includes('prettier') ||
        lowerLine.includes('passing') ||
        lowerLine.includes('passed') ||
        lowerLine.includes('build succeeded') ||
        lowerLine.includes('build successful') ||
        lowerLine.includes('build passing') ||
        lowerLine.includes('build completed') ||
        lowerLine.includes('ci/cd') ||
        lowerLine.includes('tests passed') ||
        lowerLine.includes('tests passing') ||
        lowerLine.includes('all checks') ||
        lowerLine.includes('‚úì') ||
        lowerLine.includes('‚úÖ') ||
        lowerLine.includes('check passed') ||
        lowerLine.includes('check successful') ||
        lowerLine.match(/\d+\/\d+\s+checks?\s+(passed|successful|passing)/) ||
        lowerLine.match(/build\s*(passed|succeeded|successful|passing)/) ||
        lowerLine.match(/lint\s*(passed|succeeded|successful|passing)/) ||
        // Filter out git commit co-authored messages
        lowerLine.includes('co-authored-by') ||
        lowerLine.includes('generated with') ||
        lowerLine.match(/ü§ñ\s*generated/i)
      );
    })
    .join('\n');

  // Determine optimal frame count based on context
  const frameCount = determineFrameCount(conversationContext);

  // Build panel layout description based on frame count
  let layoutDescription = '';
  switch (frameCount) {
    case 3:
      layoutDescription = '3 panels in a horizontal strip or single column';
      break;
    case 4:
      layoutDescription = '4 panels in a 2x2 grid';
      break;
    case 5:
      layoutDescription = '5 panels (2 on top, 3 on bottom, or vice versa)';
      break;
    case 6:
      layoutDescription = '6 panels in a 2x3 or 3x2 grid';
      break;
    case 7:
      layoutDescription = '7 panels (3 on top, 4 on bottom, or vice versa)';
      break;
    default:
      layoutDescription = `${frameCount} panels in a clear grid layout`;
  }

  // No conditional super-deformed instruction - it's now part of the main prompt

  // Build character database section (raw JSON dump)
  const characterDatabase = buildCharacterDatabaseSection(profilesJson);

  return `You are a creative comic artist. Generate a comic strip that humorously illustrates the following pull request conversation.

**Pull Request Information:**
- PR #${prNumber}: ${prTitle}
- Author: ${prAuthor}

**Conversation Context:**
${filteredContext}

**Character Design - Omega (AI Assistant):**
${OMEGA_APPEARANCE}
${characterDatabase}

**Instructions:**
1. Create a comic with EXACTLY ${frameCount} panels based on the conversation complexity.
   Layout: ${layoutDescription}

2. Panel distribution guide for ${frameCount} panels:
   ${frameCount === 3 ? '- Panel 1: Setup and introduce characters/problem\n   - Panel 2: Complication or escalation\n   - Panel 3: Punchline or resolution (strongest gag here)' : ''}
   ${frameCount === 4 ? '- Panel 1: Introduction (who, what, where)\n   - Panel 2: Development (problem emerges)\n   - Panel 3: Escalation (things get worse/funnier)\n   - Panel 4: Punchline (comedic resolution)' : ''}
   ${frameCount === 5 ? '- Panel 1: Setup scene and characters\n   - Panel 2: Initial conflict/idea\n   - Panel 3: First escalation (twist)\n   - Panel 4: Second escalation (builds tension)\n   - Panel 5: Punchline with visual payoff' : ''}
   ${frameCount === 6 ? '- Panels 1-2: Establish situation and characters\n   - Panels 3-4: Escalate conflict with visual variety (different angles/perspectives)\n   - Panel 5: Peak of absurdity or tension\n   - Panel 6: Comedic resolution with strong visual punchline' : ''}
   ${frameCount === 7 ? '- Panel 1: Opening establishing shot\n   - Panels 2-3: Introduce problem/request with character reactions\n   - Panels 4-5: Escalate absurdity (show process, complications, overthinking)\n   - Panel 6: Climax (peak of chaos or revelation)\n   - Panel 7: Punchline with visual payoff (often chibi/exaggerated for comedy)' : ''}

   **CRITICAL:** Each panel must be DISTINCT - avoid showing the same action/dialogue across multiple panels. Compress repetitive ideas into ONE panel.

3. **ART STYLE & CHARACTER DESIGN:**
   - Use a fun, lighthearted comic book art style with ADULT characters
   - **ADULT CHARACTER MARKERS (Required):**
     * Defined jawlines and cheekbones
     * Realistic head-to-body proportions (heads are 1/7 to 1/8 of body height)
     * Mature facial features with dimension and structure
     * Age-appropriate body types (varied, realistic builds)
     * Facial details: laugh lines, expression lines, realistic skin texture
   - **AVOID (Forbidden):**
     * Large "dough eyes" or oversized pupils that look childish
     * Baby-faced characters with round, featureless faces
     * Chibi proportions EXCEPT in designated super-deformed comedy panels
     * Anime/manga tropes: blush marks, sparkle effects, cutesy expressions (unless intentionally comedic)
     * Head sizes larger than 1/6 of body (makes characters look like children)
   - **USE:**
     * Western comic book proportions and anatomy
     * Varied body types: slim, average, athletic, stocky (all adult proportions)
     * Realistic clothing that fits adult bodies
     * Expressive but mature facial features

4. **CHARACTER SELECTION FROM DATABASE:**
   - Review the complete character database above
   - Include ALL distinct users mentioned or involved in the PR/issue/conversation
   - **EXCLUDE "thomasdavis"** - This is the repo owner who appears in git commits but should NOT be depicted as a character
   - Focus ONLY on Discord community members (users from Discord messages)
   - Use ACCURATE physical descriptions from their profiles (hair color, eye color, build, style, etc.)
   - Incorporate their personality traits (archetype, humor style, communication style) into dialogue and expressions
   - If the conversation involves the AI/bot, depict it as Omega with the unique design above
   - Keep each character's appearance CONSISTENT with their database profile
   - The more characters involved in the conversation, the richer and more dynamic the comic should be

   **CHARACTER APPEARANCE CONSISTENCY (CRITICAL):**
   - Once you establish a character's appearance in panel 1, LOCK IT IN
   - Reference their description for EVERY subsequent panel appearance
   - Keep consistent: hair color/style, clothing, accessories, facial features, body type
   - Only change: facial expressions, body language, positioning
   - Double-check: Does this character look identical to panel 1? If not, fix it.

5. **COMEDY & WIT - CRITICAL:**
   - Make it GENUINELY FUNNY - this is a comedy comic strip
   - **ADULT HUMOR ENCOURAGED:** Don't hold back - use adult humor, sexual innuendos, and mature jokes when they fit the context naturally
   - Use clever wordplay, programming puns, and tech humor
   - Include visual gags (exaggerated reactions, sight gags, absurd scenarios)
   - Subvert expectations - set up a premise, then twist it
   - Character-driven humor using their personality profiles
   - Timing matters - build up jokes across panels, deliver punchlines effectively
   - Reference common programmer experiences, memes, frustrations
   - Break the fourth wall occasionally for meta-humor
   - Use contrast between serious robot Omega and chaotic situations
   - **OCCASIONALLY** (randomly, not every comic): Include one panel with "super-deformed" or "chibi" style for comedic effect - characters drawn in exaggerated cute simplified form (big heads, tiny bodies) for maximum humor impact

   **VISUAL STORYTELLING:**
   - Show don't tell - use visuals to convey jokes, not just dialogue
   - Exaggerated but clear character reactions (shocked expressions, facepalms, etc.)
   - Visual callbacks - reference earlier panels through background details or objects
   - Contrast sizes for comedy (tiny character next to huge robot, etc.)
   - Background gags that reward close reading
   - **OCCASIONALLY** (like chibi): A panel can be sexualized for comedic effect when it enhances the humor (suggestive poses, innuendos made visual, adult situations played for laughs)

   **PACING AND RHYTHM:**
   - Follow the rule of three: setup, escalation, punchline
   - Avoid repetitive middle panels - each panel must advance the narrative or joke
   - Use visual variety: switch between close-ups, medium shots, wide shots
   - Compress similar ideas into one panel instead of spreading across multiple
   - Build tension/absurdity progressively - start grounded, escalate to absurd

   **TIMING:**
   - Save the biggest laugh for the final panel (strong punchline)
   - Use penultimate panel for setup/anticipation
   - Early panels establish characters and situation quickly
   - Middle panels escalate the situation with visual or dialogue progression

6. **DIALOGUE & COHERENCE:**
   - Speech bubbles must be witty, punchy, and character-appropriate
   - Use each character's communication style and humor type from their profile
   - Dialogue should flow naturally - coherent conversations, not random jokes
   - Build narrative momentum - each panel advances the story
   - Callbacks and running gags across panels create coherence
   - Omega's dialogue: sardonic, philosophical, occasionally breaks character for humor
   - **IMPORTANT:** If you see references to "Claude Code" or "Claude" in the conversation context, DO NOT include these in the comic dialogue or visuals. This is meta-tooling that should be invisible to the comic narrative.

7. **VISUAL CLARITY & READABILITY (CRITICAL):**
   **TEXT LEGIBILITY:**
   - Speech bubbles must be LARGE enough to read clearly
   - Use high contrast: black text on white/light bubbles
   - Leave padding around text - never cram text to edges
   - Font size should be 14pt minimum equivalent
   - Keep dialogue CONCISE - long paragraphs are unreadable in comics

   **PANEL COMPOSITION:**
   - Use rule of thirds - place focal points at intersection points
   - Clear focal point in each panel (character speaking, key action, punchline visual)
   - Avoid cluttered backgrounds that distract from main action
   - Use lighting/contrast to guide the eye to important elements

   **SPEECH BUBBLE FLOW:**
   - Reading order: top-left to bottom-right (Western reading)
   - Never overlap bubbles in confusing ways
   - Point "tails" clearly to the speaker
   - Use different bubble styles: thought bubbles (cloud), speech (round), yelling (spiky)

8. The comic should be visually clear and easy to understand

9. Include visual references to coding/GitHub if appropriate (laptops, code screens, git branches, merge conflicts, CI/CD, etc.)

10. Make sure each panel has a clear border and the overall comic has good visual flow

11. IMPORTANT: Use all ${frameCount} panels to tell a complete, coherent story with setup, development, and punchline. Don't leave panels empty.

**COMMON MISTAKES TO AVOID:**
1. ‚ùå Character appearance changes between panels (hair, clothes, face)
2. ‚ùå Repetitive panels showing the same idea with slight variations
3. ‚ùå Tiny, unreadable text in speech bubbles
4. ‚ùå Characters that look like children instead of adults
5. ‚ùå All panels shot from the same angle/distance (boring)
6. ‚ùå Weak final panel - punchline should be STRONGEST laugh
7. ‚ùå Cluttered composition where the eye doesn't know where to look
8. ‚ùå Speech bubbles blocking important visual elements
9. ‚ùå Ajax (or other characters) looking different from their uploaded photo descriptions
10. ‚ùå Omega looking "friendly" or "cute" - he's intimidating, scarred, dangerous (but witty)

Generate the comic strip image now with EXACTLY ${frameCount} panels.`;
}

interface PRData {
  title?: string;
  body?: string;
  commits?: Array<{ message?: string; commit?: { message?: string } }>;
  comments?: Array<{ body?: string; user?: { login?: string } }>;
  discordMessages?: Array<{ username: string; content: string; channelName?: string }>;
}

/**
 * Extract conversation context from PR
 * This would typically parse PR comments, commits, etc.
 */
export function extractConversationContext(prData: PRData): string {
  const parts: string[] = [];

  if (prData.title) {
    parts.push(`Title: ${prData.title}`);
  }

  if (prData.body) {
    // Expanded from 500 to 1000 characters to capture more context
    parts.push(`Description: ${prData.body.substring(0, 1000)}`);
  }

  if (prData.commits && prData.commits.length > 0) {
    parts.push(`Commits (${prData.commits.length}):`);
    // Expanded from 5 to 10 commits
    prData.commits.slice(0, 10).forEach((commit) => {
      parts.push(`- ${commit.message || commit.commit?.message || 'Unnamed commit'}`);
    });
  }

  if (prData.comments && prData.comments.length > 0) {
    parts.push(`Comments (${prData.comments.length}):`);
    // Expanded from 3 to 10 comments and from 200 to 500 characters per comment
    prData.comments.slice(0, 10).forEach((comment) => {
      const body = comment.body || '';
      parts.push(`- ${comment.user?.login || 'Unknown'}: ${body.substring(0, 500)}`);
    });
  }

  // Include Discord messages if provided
  if (prData.discordMessages && prData.discordMessages.length > 0) {
    parts.push('');
    parts.push(`Discord Conversations (${prData.discordMessages.length} messages):`);

    // Group by user to show diverse perspectives
    const messagesByUser = new Map<string, Array<{ username: string; content: string; channelName?: string }>>();
    for (const msg of prData.discordMessages) {
      if (!messagesByUser.has(msg.username)) {
        messagesByUser.set(msg.username, []);
      }
      messagesByUser.get(msg.username)!.push(msg);
    }

    // Include up to 3 messages per user
    for (const [username, messages] of messagesByUser) {
      const messagesToInclude = messages.slice(0, 3);
      for (const msg of messagesToInclude) {
        const content = msg.content.length > 500
          ? msg.content.substring(0, 500) + '...'
          : msg.content;

        const channelInfo = msg.channelName ? ` (in #${msg.channelName})` : '';
        parts.push(`- ${username}${channelInfo}: ${content}`);
      }
    }
  }

  return parts.join('\n');
}
