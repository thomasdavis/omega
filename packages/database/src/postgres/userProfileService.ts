/**
 * PostgreSQL User Profile Service
 * Refactored to use Prisma ORM for type-safe database operations
 * CRUD operations for user_profiles and user_analysis_history tables
 */

import { prisma } from './prismaClient.js';
import { Prisma } from '@prisma/client';
import { UserProfileRecord, UserAnalysisHistoryRecord } from './schema.js';
import { randomUUID } from 'crypto'; // Still used for analysis history

/**
 * Set of valid Prisma field names for UserProfile.
 * The schema has mixed naming: some fields are snake_case (e.g. feelings_json),
 * some are camelCase with @map (e.g. attachmentStyle @map("attachment_style")).
 * We use this set to resolve the correct Prisma field name when writing updates.
 */
const VALID_PROFILE_FIELDS = new Set(
  Object.values(Prisma.UserProfileScalarFieldEnum)
);

/**
 * Convert Prisma camelCase object to snake_case record
 * Prisma returns camelCase (e.g. userId) but record types use snake_case (user_id)
 */
function toSnakeCase(obj: any): any {
  if (!obj || typeof obj !== 'object' || Array.isArray(obj)) return obj;
  const result: any = {};
  for (const [key, value] of Object.entries(obj)) {
    const snakeKey = key.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);
    // Convert BigInt to number for timestamp fields
    result[snakeKey] = typeof value === 'bigint' ? Number(value) : value;
  }
  return result;
}

/**
 * Get user profile by Discord user ID
 */
export async function getUserProfile(userId: string): Promise<UserProfileRecord | null> {
  const profile = await prisma.userProfile.findUnique({
    where: { userId },
  });

  if (!profile) {
    return null;
  }

  return toSnakeCase(profile) as UserProfileRecord;
}

/**
 * Create a new user profile
 */
export async function createUserProfile(userId: string, username: string): Promise<string> {
  // Validate userId is a Discord Snowflake (numeric string, 17-20 digits)
  if (!/^\d{17,20}$/.test(userId)) {
    throw new Error(
      `Invalid userId: "${userId}" - Discord IDs must be 17-20 digit numeric strings. ` +
      `Possible parameter swap detected (userId="${userId}", username="${username}").`
    );
  }

  // Validate username is not a numeric Discord ID (likely parameter swap)
  if (/^\d{17,20}$/.test(username)) {
    throw new Error(
      `Invalid username: "${username}" - Username appears to be a Discord ID. ` +
      `Possible parameter swap detected (userId="${userId}", username="${username}").`
    );
  }

  const now = BigInt(Math.floor(Date.now() / 1000));

  // ID is now auto-generated by database DEFAULT gen_random_uuid()::text
  const profile = await prisma.userProfile.create({
    data: {
      userId,
      username,
      firstSeenAt: now,
      lastInteractionAt: now,
      messageCount: 0,
      appearanceConfidence: 0.0,
    },
  });

  return profile.id;
}

/**
 * Update user profile
 */
export async function updateUserProfile(
  userId: string,
  updates: Partial<Omit<UserProfileRecord, 'user_id' | 'created_at'>>
): Promise<void> {
  const now = BigInt(Math.floor(Date.now() / 1000));

  const prismaUpdates: any = {
    updatedAt: now,
  };

  // Helper function to convert snake_case to camelCase
  const snakeToCamel = (str: string): string => {
    return str.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());
  };

  // Resolve update keys to valid Prisma field names.
  // The schema has mixed naming: some fields are snake_case (feelings_json),
  // some are camelCase with @map (attachmentStyle). We check the key as-is first,
  // then try camelCase conversion.
  for (const [key, value] of Object.entries(updates)) {
    if (value !== undefined && key !== 'id' && key !== 'user_id') {
      if (VALID_PROFILE_FIELDS.has(key as any)) {
        // Key is already a valid Prisma field name (e.g. feelings_json, openness_score)
        prismaUpdates[key] = value;
      } else {
        // Try camelCase conversion (e.g. attachment_style ‚Üí attachmentStyle)
        const camelKey = snakeToCamel(key);
        if (VALID_PROFILE_FIELDS.has(camelKey as any)) {
          prismaUpdates[camelKey] = value;
        }
        // Skip unknown fields silently
      }
    }
  }

  await prisma.userProfile.update({
    where: { userId },
    data: prismaUpdates,
  });
}

/**
 * Get or create user profile
 * Ensures a profile exists for the given user
 */
export async function getOrCreateUserProfile(
  userId: string,
  username: string
): Promise<UserProfileRecord> {
  let profile = await getUserProfile(userId);

  if (!profile) {
    await createUserProfile(userId, username);
    profile = await getUserProfile(userId);
  } else if (profile.username !== username) {
    // User changed their Discord username - update it
    console.log(`üìù Username changed for ${userId}: "${profile.username}" ‚Üí "${username}"`);
    await updateUserProfile(userId, { username });
    profile = await getUserProfile(userId);
  }

  return profile!;
}

/**
 * Get users needing analysis
 * Returns users who have new messages since last analysis
 */
export async function getUsersNeedingAnalysis(limit = 100): Promise<UserProfileRecord[]> {
  const profiles = await prisma.userProfile.findMany({
    where: {
      OR: [
        { lastAnalyzedAt: null },
        {
          lastAnalyzedAt: {
            lt: prisma.userProfile.fields.lastInteractionAt,
          },
        },
      ],
    },
    orderBy: { lastInteractionAt: 'desc' },
    take: limit,
  });

  return profiles.map(p => toSnakeCase(p) as UserProfileRecord);
}

/**
 * Save analysis history snapshot
 */
export async function saveAnalysisHistory(
  userId: string,
  feelingsSnapshot: string,
  personalitySnapshot: string,
  messageCount: number,
  changesSummary?: string
): Promise<string> {
  const id = randomUUID();
  const now = BigInt(Math.floor(Date.now() / 1000));

  // Parse snapshots to JSONB
  let feelingsJsonb = null;
  let personalityJsonb = null;

  try {
    feelingsJsonb = JSON.parse(feelingsSnapshot);
  } catch {
    feelingsJsonb = { raw: feelingsSnapshot };
  }

  try {
    personalityJsonb = JSON.parse(personalitySnapshot);
  } catch {
    personalityJsonb = { raw: personalitySnapshot };
  }

  await prisma.userAnalysisHistory.create({
    data: {
      id,
      userId,
      analysisTimestamp: now,
      feelingsSnapshot: feelingsJsonb,
      personalitySnapshot: personalityJsonb,
      messageCountAtAnalysis: messageCount,
      changesSummary: changesSummary || null,
    },
  });

  return id;
}

/**
 * Get analysis history for a user
 */
export async function getAnalysisHistory(
  userId: string,
  limit = 10
): Promise<UserAnalysisHistoryRecord[]> {
  const history = await prisma.userAnalysisHistory.findMany({
    where: { userId },
    orderBy: { analysisTimestamp: 'desc' },
    take: limit,
  });

  return history as any as UserAnalysisHistoryRecord[];
}

/**
 * Increment message count for a user
 */
export async function incrementMessageCount(userId: string): Promise<void> {
  const now = BigInt(Math.floor(Date.now() / 1000));

  await prisma.userProfile.update({
    where: { userId },
    data: {
      messageCount: { increment: 1 },
      lastInteractionAt: now,
      updatedAt: now,
    },
  });
}

/**
 * Get all user profiles (for batch analysis)
 */
export async function getAllUserProfiles(limit = 1000): Promise<UserProfileRecord[]> {
  const profiles = await prisma.userProfile.findMany({
    orderBy: { lastInteractionAt: 'desc' },
    take: limit,
  });

  return profiles.map(p => toSnakeCase(p) as UserProfileRecord);
}
