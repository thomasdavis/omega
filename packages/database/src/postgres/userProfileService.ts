/**
 * PostgreSQL User Profile Service
 * Refactored to use Prisma ORM for type-safe database operations
 * CRUD operations for user_profiles and user_analysis_history tables
 */

import { prisma } from './prismaClient.js';
import { Prisma } from '@prisma/client';
import { UserProfileRecord, UserAnalysisHistoryRecord } from './schema.js';
import { randomUUID } from 'crypto'; // Still used for analysis history

/**
 * Set of valid Prisma field names for UserProfile.
 * The schema has mixed naming: some fields are snake_case (e.g. feelings_json),
 * some are camelCase with @map (e.g. attachmentStyle @map("attachment_style")).
 * We use this set to resolve the correct Prisma field name when writing updates.
 */
const VALID_PROFILE_FIELDS = new Set(
  Object.values(Prisma.UserProfileScalarFieldEnum)
);

/**
 * Convert Prisma camelCase object to snake_case record
 * Prisma returns camelCase (e.g. userId) but record types use snake_case (user_id)
 */
function toSnakeCase(obj: any): any {
  if (!obj || typeof obj !== 'object' || Array.isArray(obj)) return obj;
  const result: any = {};
  for (const [key, value] of Object.entries(obj)) {
    const snakeKey = key.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);
    // Convert BigInt to number for timestamp fields
    result[snakeKey] = typeof value === 'bigint' ? Number(value) : value;
  }
  return result;
}

/**
 * Get user profile by Discord user ID
 */
export async function getUserProfile(userId: string): Promise<UserProfileRecord | null> {
  const profile = await prisma.userProfile.findUnique({
    where: { userId },
  });

  if (!profile) {
    return null;
  }

  return toSnakeCase(profile) as UserProfileRecord;
}

/**
 * Create a new user profile
 */
export async function createUserProfile(userId: string, username: string): Promise<string> {
  // Validate userId is a Discord Snowflake (numeric string, 17-20 digits)
  if (!/^\d{17,20}$/.test(userId)) {
    throw new Error(
      `Invalid userId: "${userId}" - Discord IDs must be 17-20 digit numeric strings. ` +
      `Possible parameter swap detected (userId="${userId}", username="${username}").`
    );
  }

  // Validate username is not a numeric Discord ID (likely parameter swap)
  if (/^\d{17,20}$/.test(username)) {
    throw new Error(
      `Invalid username: "${username}" - Username appears to be a Discord ID. ` +
      `Possible parameter swap detected (userId="${userId}", username="${username}").`
    );
  }

  const now = BigInt(Math.floor(Date.now() / 1000));

  // ID is now auto-generated by database DEFAULT gen_random_uuid()::text
  const profile = await prisma.userProfile.create({
    data: {
      userId,
      username,
      firstSeenAt: now,
      lastInteractionAt: now,
      messageCount: 0,
      appearanceConfidence: 0.0,
    },
  });

  return profile.id;
}

/**
 * Update user profile
 */
export async function updateUserProfile(
  userId: string,
  updates: Partial<Omit<UserProfileRecord, 'user_id' | 'created_at'>>
): Promise<void> {
  const now = BigInt(Math.floor(Date.now() / 1000));

  const prismaUpdates: any = {
    updatedAt: now,
  };

  // Helper function to convert snake_case to camelCase
  const snakeToCamel = (str: string): string => {
    return str.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());
  };

  // Resolve update keys to valid Prisma field names.
  // The schema has mixed naming: some fields are snake_case (feelings_json),
  // some are camelCase with @map (attachmentStyle). We check the key as-is first,
  // then try camelCase conversion.
  for (const [key, value] of Object.entries(updates)) {
    if (value !== undefined && key !== 'id' && key !== 'user_id') {
      if (VALID_PROFILE_FIELDS.has(key as any)) {
        // Key is already a valid Prisma field name (e.g. feelings_json, openness_score)
        prismaUpdates[key] = value;
      } else {
        // Try camelCase conversion (e.g. attachment_style ‚Üí attachmentStyle)
        const camelKey = snakeToCamel(key);
        if (VALID_PROFILE_FIELDS.has(camelKey as any)) {
          prismaUpdates[camelKey] = value;
        }
        // Skip unknown fields silently
      }
    }
  }

  await prisma.userProfile.update({
    where: { userId },
    data: prismaUpdates,
  });
}

/**
 * Get or create user profile
 * Ensures a profile exists for the given user
 */
export async function getOrCreateUserProfile(
  userId: string,
  username: string
): Promise<UserProfileRecord> {
  let profile = await getUserProfile(userId);

  if (!profile) {
    await createUserProfile(userId, username);
    profile = await getUserProfile(userId);
  } else if (profile.username !== username) {
    // User changed their Discord username - update it
    console.log(`üìù Username changed for ${userId}: "${profile.username}" ‚Üí "${username}"`);
    await updateUserProfile(userId, { username });
    profile = await getUserProfile(userId);
  }

  return profile!;
}

/**
 * Get users needing analysis
 * Returns users who have new messages since last analysis
 */
export async function getUsersNeedingAnalysis(limit = 100): Promise<UserProfileRecord[]> {
  const profiles = await prisma.userProfile.findMany({
    where: {
      OR: [
        { lastAnalyzedAt: null },
        {
          lastAnalyzedAt: {
            lt: prisma.userProfile.fields.lastInteractionAt,
          },
        },
      ],
    },
    orderBy: { lastInteractionAt: 'desc' },
    take: limit,
  });

  return profiles.map(p => toSnakeCase(p) as UserProfileRecord);
}

/**
 * Save analysis history snapshot ‚Äî stores FULL snapshot of all long-form fields
 */
export async function saveAnalysisHistory(
  userId: string,
  feelingsSnapshot: string,
  personalitySnapshot: string,
  messageCount: number,
  changesSummary?: string,
  fullSnapshot?: {
    omega_rating?: number | null;
    omega_rating_reason?: string | null;
    psychological_profile?: string | null;
    communication_analysis?: string | null;
    relationship_narrative?: string | null;
    personality_evolution?: string | null;
    behavioral_deep_dive?: string | null;
    interests_analysis?: string | null;
    emotional_landscape?: string | null;
    social_dynamics_analysis?: string | null;
    interaction_style_with_others?: string | null;
    omega_thoughts?: string | null;
    trust_level?: number | null;
    affinity_score?: number | null;
    overall_sentiment?: string | null;
    analysis_version?: number | null;
    integrated_profile_summary?: string | null;
  }
): Promise<string> {
  const id = randomUUID();
  const now = BigInt(Math.floor(Date.now() / 1000));

  // Parse snapshots to JSONB
  let feelingsJsonb = null;
  let personalityJsonb = null;

  try {
    feelingsJsonb = JSON.parse(feelingsSnapshot);
  } catch {
    feelingsJsonb = { raw: feelingsSnapshot };
  }

  try {
    personalityJsonb = JSON.parse(personalitySnapshot);
  } catch {
    personalityJsonb = { raw: personalitySnapshot };
  }

  await prisma.userAnalysisHistory.create({
    data: {
      id,
      userId,
      analysisTimestamp: now,
      feelingsSnapshot: feelingsJsonb,
      personalitySnapshot: personalityJsonb,
      messageCountAtAnalysis: messageCount,
      changesSummary: changesSummary || null,
      // Full snapshot fields
      omega_rating: fullSnapshot?.omega_rating ?? null,
      omega_rating_reason: fullSnapshot?.omega_rating_reason ?? null,
      psychological_profile: fullSnapshot?.psychological_profile ?? null,
      communication_analysis: fullSnapshot?.communication_analysis ?? null,
      relationship_narrative: fullSnapshot?.relationship_narrative ?? null,
      personality_evolution: fullSnapshot?.personality_evolution ?? null,
      behavioral_deep_dive: fullSnapshot?.behavioral_deep_dive ?? null,
      interests_analysis: fullSnapshot?.interests_analysis ?? null,
      emotional_landscape: fullSnapshot?.emotional_landscape ?? null,
      social_dynamics_analysis: fullSnapshot?.social_dynamics_analysis ?? null,
      interaction_style_with_others: fullSnapshot?.interaction_style_with_others ?? null,
      omega_thoughts: fullSnapshot?.omega_thoughts ?? null,
      trust_level: fullSnapshot?.trust_level ?? null,
      affinity_score: fullSnapshot?.affinity_score ?? null,
      overall_sentiment: fullSnapshot?.overall_sentiment ?? null,
      analysis_version: fullSnapshot?.analysis_version ?? null,
      integrated_profile_summary: fullSnapshot?.integrated_profile_summary ?? null,
    },
  });

  return id;
}

/**
 * Get analysis history for a user
 */
export async function getAnalysisHistory(
  userId: string,
  limit = 10
): Promise<UserAnalysisHistoryRecord[]> {
  const history = await prisma.userAnalysisHistory.findMany({
    where: { userId },
    orderBy: { analysisTimestamp: 'desc' },
    take: limit,
  });

  return history as any as UserAnalysisHistoryRecord[];
}

/**
 * Increment message count for a user
 */
export async function incrementMessageCount(userId: string): Promise<void> {
  const now = BigInt(Math.floor(Date.now() / 1000));

  await prisma.userProfile.update({
    where: { userId },
    data: {
      messageCount: { increment: 1 },
      lastInteractionAt: now,
      updatedAt: now,
    },
  });
}

/**
 * Get all user profiles (for batch analysis)
 */
export async function getAllUserProfiles(limit = 1000): Promise<UserProfileRecord[]> {
  const profiles = await prisma.userProfile.findMany({
    orderBy: { lastInteractionAt: 'desc' },
    take: limit,
  });

  return profiles.map(p => toSnakeCase(p) as UserProfileRecord);
}

/**
 * Result of a profile deletion operation
 */
export interface ProfileDeletionResult {
  success: boolean;
  userId: string;
  username: string;
  tablesAffected: string[];
  recordsDeleted: Record<string, number>;
  auditId: string;
}

/**
 * Delete a user profile and all associated data across all tables.
 * Implements "right to be forgotten" ‚Äî comprehensive data removal.
 *
 * Access control: requestingUserId must match the profile's userId.
 *
 * Deletes from (in order):
 * - user_analysis_history (CASCADE from user_profiles, but explicit for counting)
 * - document_collaborators (user's collaborations)
 * - documents (created by user)
 * - user_feelings
 * - generated_images
 * - user_affinities (both sides)
 * - collaboration_history (both sides)
 * - collaboration_predictions (both sides)
 * - script_storage
 * - todo_list
 * - conversation_messages + conversations
 * - agent_syntheses
 * - abc_sheet_music, midi_files, mp3_files, video_files (created by user)
 * - queries
 * - messages (user's messages)
 * - user_profiles (triggers CASCADE for user_analysis_history)
 */
export async function deleteUserProfile(
  userId: string,
  requestingUserId: string,
): Promise<ProfileDeletionResult> {
  // Access control: only the profile owner can delete their profile
  if (userId !== requestingUserId) {
    throw new Error(
      'Access denied: You can only delete your own profile. ' +
      `Requested deletion of ${userId} by ${requestingUserId}.`
    );
  }

  // Verify profile exists
  const profile = await prisma.userProfile.findUnique({
    where: { userId },
  });

  if (!profile) {
    throw new Error(`Profile not found for user ID: ${userId}`);
  }

  const username = profile.username;
  const now = BigInt(Math.floor(Date.now() / 1000));
  const recordsDeleted: Record<string, number> = {};
  const tablesAffected: string[] = [];

  // Use a transaction for atomicity
  await prisma.$transaction(async (tx) => {
    // 1. Delete user_analysis_history (also CASCADE'd, but count explicitly)
    const analysisDeleted = await tx.userAnalysisHistory.deleteMany({
      where: { userId },
    });
    if (analysisDeleted.count > 0) {
      recordsDeleted['user_analysis_history'] = analysisDeleted.count;
      tablesAffected.push('user_analysis_history');
    }

    // 2. Delete document_collaborators for this user
    const collabsDeleted = await tx.documentCollaborator.deleteMany({
      where: { userId },
    });
    if (collabsDeleted.count > 0) {
      recordsDeleted['document_collaborators'] = collabsDeleted.count;
      tablesAffected.push('document_collaborators');
    }

    // 3. Delete documents created by this user (CASCADE deletes their collaborators)
    const docsDeleted = await tx.document.deleteMany({
      where: { createdBy: userId },
    });
    if (docsDeleted.count > 0) {
      recordsDeleted['documents'] = docsDeleted.count;
      tablesAffected.push('documents');
    }

    // 4. Delete user_feelings
    const feelingsDeleted = await tx.userFeeling.deleteMany({
      where: { userId },
    });
    if (feelingsDeleted.count > 0) {
      recordsDeleted['user_feelings'] = feelingsDeleted.count;
      tablesAffected.push('user_feelings');
    }

    // 5. Delete generated_images
    const imagesDeleted = await tx.generatedImage.deleteMany({
      where: { userId },
    });
    if (imagesDeleted.count > 0) {
      recordsDeleted['generated_images'] = Number(imagesDeleted.count);
      tablesAffected.push('generated_images');
    }

    // 6. Delete user_affinities (both sides)
    const affinities1 = await tx.userAffinity.deleteMany({
      where: { userId1: userId },
    });
    const affinities2 = await tx.userAffinity.deleteMany({
      where: { userId2: userId },
    });
    const totalAffinities = affinities1.count + affinities2.count;
    if (totalAffinities > 0) {
      recordsDeleted['user_affinities'] = totalAffinities;
      tablesAffected.push('user_affinities');
    }

    // 7. Delete collaboration_history (both sides)
    const collabHist1 = await tx.collaborationHistory.deleteMany({
      where: { userId1: userId },
    });
    const collabHist2 = await tx.collaborationHistory.deleteMany({
      where: { userId2: userId },
    });
    const totalCollabHist = collabHist1.count + collabHist2.count;
    if (totalCollabHist > 0) {
      recordsDeleted['collaboration_history'] = totalCollabHist;
      tablesAffected.push('collaboration_history');
    }

    // 8. Delete collaboration_predictions (both sides)
    const collabPred1 = await tx.collaborationPrediction.deleteMany({
      where: { userId1: userId },
    });
    const collabPred2 = await tx.collaborationPrediction.deleteMany({
      where: { userId2: userId },
    });
    const totalCollabPred = collabPred1.count + collabPred2.count;
    if (totalCollabPred > 0) {
      recordsDeleted['collaboration_predictions'] = totalCollabPred;
      tablesAffected.push('collaboration_predictions');
    }

    // 9. Delete script_storage
    const scriptsDeleted = await tx.scriptStorage.deleteMany({
      where: { userId },
    });
    if (scriptsDeleted.count > 0) {
      recordsDeleted['script_storage'] = scriptsDeleted.count;
      tablesAffected.push('script_storage');
    }

    // 10. Delete todo_list
    const todosDeleted = await tx.todoList.deleteMany({
      where: { userId },
    });
    if (todosDeleted.count > 0) {
      recordsDeleted['todo_list'] = todosDeleted.count;
      tablesAffected.push('todo_list');
    }

    // 11. Delete conversations (CASCADE deletes conversation_messages)
    const conversationsDeleted = await tx.conversation.deleteMany({
      where: { userId },
    });
    if (conversationsDeleted.count > 0) {
      recordsDeleted['conversations'] = conversationsDeleted.count;
      tablesAffected.push('conversations');
    }

    // 12. Delete agent_syntheses
    const synthesisDeleted = await tx.agentSynthesis.deleteMany({
      where: { userId },
    });
    if (synthesisDeleted.count > 0) {
      recordsDeleted['agent_syntheses'] = synthesisDeleted.count;
      tablesAffected.push('agent_syntheses');
    }

    // 13. Delete music/media created by this user
    const abcDeleted = await tx.abcSheetMusic.deleteMany({
      where: { createdBy: userId },
    });
    if (abcDeleted.count > 0) {
      recordsDeleted['abc_sheet_music'] = abcDeleted.count;
      tablesAffected.push('abc_sheet_music');
    }

    const midiDeleted = await tx.midiFile.deleteMany({
      where: { createdBy: userId },
    });
    if (midiDeleted.count > 0) {
      recordsDeleted['midi_files'] = midiDeleted.count;
      tablesAffected.push('midi_files');
    }

    const mp3Deleted = await tx.mp3File.deleteMany({
      where: { createdBy: userId },
    });
    if (mp3Deleted.count > 0) {
      recordsDeleted['mp3_files'] = mp3Deleted.count;
      tablesAffected.push('mp3_files');
    }

    const videoDeleted = await tx.videoFile.deleteMany({
      where: { createdBy: userId },
    });
    if (videoDeleted.count > 0) {
      recordsDeleted['video_files'] = videoDeleted.count;
      tablesAffected.push('video_files');
    }

    // 14. Delete queries
    const queriesDeleted = await tx.query.deleteMany({
      where: { userId },
    });
    if (queriesDeleted.count > 0) {
      recordsDeleted['queries'] = queriesDeleted.count;
      tablesAffected.push('queries');
    }

    // 15. Delete messages
    const messagesDeleted = await tx.message.deleteMany({
      where: { userId },
    });
    if (messagesDeleted.count > 0) {
      recordsDeleted['messages'] = messagesDeleted.count;
      tablesAffected.push('messages');
    }

    // 16. Finally, delete the user profile (CASCADE handles analysis_history)
    await tx.userProfile.delete({
      where: { userId },
    });
    recordsDeleted['user_profiles'] = 1;
    tablesAffected.push('user_profiles');
  });

  // Log the deletion to the audit table (outside transaction, using raw SQL
  // since profile_deletion_audit is not yet in Prisma schema)
  const auditId = randomUUID();
  const nowNum = Number(now);
  await prisma.$executeRaw`
    INSERT INTO profile_deletion_audit (id, user_id, username, requested_at, completed_at, status, tables_affected, records_deleted, requested_by, created_at)
    VALUES (${auditId}, ${userId}, ${username}, ${nowNum}, ${nowNum}, 'completed', ${JSON.stringify(tablesAffected)}::jsonb, ${JSON.stringify(recordsDeleted)}::jsonb, ${requestingUserId}, ${nowNum})
  `;

  return {
    success: true,
    userId,
    username,
    tablesAffected,
    recordsDeleted,
    auditId,
  };
}
