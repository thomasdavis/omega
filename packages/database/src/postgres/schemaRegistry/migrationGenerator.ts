import type { TableSchemaDefinition, ColumnDefinition, IndexDefinition } from './types.js';

export interface MigrationFiles {
  up: string;
  down: string;
}

/**
 * Generates SQL migration files from a table schema definition
 */
export class MigrationGenerator {
  /**
   * Generate up and down migration SQL for creating a new table
   */
  static generateCreateTableMigration(schema: TableSchemaDefinition): MigrationFiles {
    const upSql = this.generateCreateTableSQL(schema);
    const downSql = this.generateDropTableSQL(schema.tableName);

    return {
      up: upSql,
      down: downSql
    };
  }

  /**
   * Generate SQL to create a table with all columns, constraints, and indexes
   */
  private static generateCreateTableSQL(schema: TableSchemaDefinition): string {
    const lines: string[] = [];

    // Start table creation
    lines.push(`-- Create table ${schema.tableName}`);
    if (schema.comment) {
      lines.push(`-- ${schema.comment}`);
    }
    lines.push(`CREATE TABLE IF NOT EXISTS ${schema.tableName} (`);

    // Add column definitions
    const columnDefs = schema.columns.map(col => this.generateColumnSQL(col));
    lines.push(columnDefs.map(def => `  ${def}`).join(',\n'));

    lines.push(');');
    lines.push('');

    // Add column comments
    schema.columns
      .filter(col => col.comment)
      .forEach(col => {
        lines.push(
          `COMMENT ON COLUMN ${schema.tableName}.${col.name} IS '${this.escapeSQLString(col.comment!)}';`
        );
      });

    if (schema.columns.some(col => col.comment)) {
      lines.push('');
    }

    // Add table comment
    if (schema.comment) {
      lines.push(`COMMENT ON TABLE ${schema.tableName} IS '${this.escapeSQLString(schema.comment)}';`);
      lines.push('');
    }

    // Add indexes
    if (schema.indexes && schema.indexes.length > 0) {
      lines.push(`-- Create indexes for ${schema.tableName}`);
      schema.indexes.forEach(idx => {
        lines.push(this.generateIndexSQL(schema.tableName, idx));
      });
      lines.push('');
    }

    return lines.join('\n');
  }

  /**
   * Generate SQL for a single column definition
   */
  private static generateColumnSQL(col: ColumnDefinition): string {
    const parts: string[] = [col.name];

    // Type
    parts.push(col.type);

    // Primary key
    if (col.primaryKey) {
      parts.push('PRIMARY KEY');
    }

    // Unique constraint
    if (col.unique && !col.primaryKey) {
      parts.push('UNIQUE');
    }

    // Nullable
    if (!col.nullable && !col.primaryKey) {
      parts.push('NOT NULL');
    }

    // Default value
    if (col.defaultValue) {
      parts.push(`DEFAULT ${col.defaultValue}`);
    }

    // Foreign key reference
    if (col.references) {
      const ref = col.references;
      let refSQL = `REFERENCES ${ref.table}(${ref.column})`;
      if (ref.onDelete) {
        refSQL += ` ON DELETE ${ref.onDelete}`;
      }
      if (ref.onUpdate) {
        refSQL += ` ON UPDATE ${ref.onUpdate}`;
      }
      parts.push(refSQL);
    }

    return parts.join(' ');
  }

  /**
   * Generate SQL to create an index
   */
  private static generateIndexSQL(tableName: string, idx: IndexDefinition): string {
    const uniqueKeyword = idx.unique ? 'UNIQUE ' : '';
    const method = idx.type !== 'BTREE' ? ` USING ${idx.type}` : '';
    const columns = idx.columns.join(', ');

    return `CREATE ${uniqueKeyword}INDEX IF NOT EXISTS ${idx.name} ON ${tableName}${method} (${columns});`;
  }

  /**
   * Generate SQL to drop a table
   */
  private static generateDropTableSQL(tableName: string): string {
    return `-- Drop table ${tableName}\nDROP TABLE IF EXISTS ${tableName} CASCADE;`;
  }

  /**
   * Escape single quotes in SQL strings
   */
  private static escapeSQLString(str: string): string {
    return str.replace(/'/g, "''");
  }

  /**
   * Generate migration file name based on timestamp and table name
   */
  static generateMigrationFileName(tableName: string): string {
    const timestamp = new Date().toISOString().replace(/[-:]/g, '').replace(/\..+/, '').replace('T', '_');
    return `${timestamp}_create_${tableName}`;
  }

  /**
   * Format the complete migration file content with metadata
   */
  static formatMigrationFile(
    direction: 'up' | 'down',
    sql: string,
    metadata: {
      tableName: string;
      requestedBy?: string;
      relatedIssue?: string;
    }
  ): string {
    const lines: string[] = [];

    lines.push('-- Migration generated by Schema Registry');
    lines.push(`-- Table: ${metadata.tableName}`);
    lines.push(`-- Direction: ${direction}`);
    if (metadata.requestedBy) {
      lines.push(`-- Requested by: ${metadata.requestedBy}`);
    }
    if (metadata.relatedIssue) {
      lines.push(`-- Related issue: ${metadata.relatedIssue}`);
    }
    lines.push(`-- Generated at: ${new Date().toISOString()}`);
    lines.push('');
    lines.push(sql);

    return lines.join('\n');
  }
}
