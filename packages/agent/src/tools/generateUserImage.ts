/**
 * Generate User Image Tool - AI-powered image generation service
 *
 * Features:
 * - Generates images from text prompts using Google's Gemini API
 * - Creates high-quality AI-generated images
 * - Returns image URLs that can be posted directly to Discord
 * - Supports various styles and creative directions
 * - Uses the same model as GeminiComicService for consistency
 */

import { tool } from 'ai';
import { z } from 'zod';
import { GoogleGenerativeAI } from '@google/generative-ai';
import fs from 'fs/promises';
import path from 'path';
import { saveGeneratedImage } from '@repo/database';
import { getUploadsDir } from '@repo/shared';
import { randomUUID } from 'crypto';

// GitHub configuration for permanent storage
const GITHUB_TOKEN = process.env.GITHUB_TOKEN;
const GITHUB_REPO = process.env.GITHUB_REPO || 'thomasdavis/omega';
const GITHUB_STORAGE_PATH = 'file-library'; // Same as fileUpload tool

/**
 * Upload image to GitHub repository for permanent, accessible storage
 */
async function uploadImageToGitHub(
  imageBuffer: Buffer,
  filename: string,
  prompt: string,
  username?: string
): Promise<{ githubUrl: string; rawUrl: string } | null> {
  if (!GITHUB_TOKEN) {
    console.log('‚ö†Ô∏è  GitHub token not configured, skipping GitHub upload');
    return null;
  }

  const filePath = `${GITHUB_STORAGE_PATH}/${filename}`;
  const base64Content = imageBuffer.toString('base64');

  try {
    // Check if file already exists (to get SHA for updates)
    let sha: string | undefined;
    const checkResponse = await fetch(
      `https://api.github.com/repos/${GITHUB_REPO}/contents/${filePath}`,
      {
        headers: {
          'Authorization': `Bearer ${GITHUB_TOKEN}`,
          'Accept': 'application/vnd.github+json',
          'X-GitHub-Api-Version': '2022-11-28',
        },
      }
    );

    if (checkResponse.ok) {
      const existingFile: any = await checkResponse.json();
      sha = existingFile.sha;
      console.log(`üìù File ${filename} exists, updating with SHA: ${sha}`);
    }

    // Upload file to GitHub
    const uploadResponse = await fetch(
      `https://api.github.com/repos/${GITHUB_REPO}/contents/${filePath}`,
      {
        method: 'PUT',
        headers: {
          'Authorization': `Bearer ${GITHUB_TOKEN}`,
          'Accept': 'application/vnd.github+json',
          'Content-Type': 'application/json',
          'X-GitHub-Api-Version': '2022-11-28',
        },
        body: JSON.stringify({
          message: `Generated image: ${prompt.substring(0, 50)}${prompt.length > 50 ? '...' : ''}${username ? ` by ${username}` : ''}`,
          content: base64Content,
          ...(sha && { sha }), // Include SHA if updating existing file
        }),
      }
    );

    if (!uploadResponse.ok) {
      const error = await uploadResponse.text();
      throw new Error(`GitHub API error: ${uploadResponse.status} - ${error}`);
    }

    const uploadData: any = await uploadResponse.json();
    const githubUrl = uploadData.content.html_url;
    const rawUrl = uploadData.content.download_url;

    console.log(`‚úÖ Uploaded to GitHub: ${githubUrl}`);
    console.log(`üîó Raw URL (direct access): ${rawUrl}`);

    return { githubUrl, rawUrl };
  } catch (error) {
    console.error('‚ùå Error uploading to GitHub:', error);
    return null;
  }
}

/**
 * Generate an image using Google's Gemini API
 * Uses the same model as GeminiComicService for consistency
 */
async function generateImage(
  prompt: string,
  userId?: string,
  username?: string,
  discordMessageId?: string
): Promise<{
  imageUrl: string;
  revisedPrompt?: string;
  imageData?: Buffer;
  filename?: string;
}> {
  try {
    // Validate API key
    if (!process.env.GEMINI_API_KEY) {
      throw new Error('GEMINI_API_KEY environment variable is not set');
    }

    // Initialize Gemini API client
    const genai = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);

    // Use the same model as GeminiComicService
    const model = genai.getGenerativeModel({
      model: 'gemini-3-pro-image-preview',
    });

    const result = await model.generateContent(prompt);

    // Extract image data from response
    const response = await result.response;

    if (!response.candidates || response.candidates.length === 0) {
      console.error('‚ùå No candidates in Gemini response');
      console.error('Response:', JSON.stringify(response, null, 2));
      throw new Error('No image generated by Gemini API');
    }

    const candidate = response.candidates[0];
    if (!candidate.content?.parts) {
      console.error('‚ùå No content parts in candidate');
      console.error('Candidate:', JSON.stringify(candidate, null, 2));
      throw new Error('Invalid response structure from Gemini API');
    }

    // Find the image part in the response
    let imageData: Buffer | undefined;
    for (const part of candidate.content.parts) {
      // Check for inline data (base64 encoded image)
      if ((part as any).inlineData?.mimeType?.startsWith('image/')) {
        const base64Data = (part as any).inlineData.data;
        imageData = Buffer.from(base64Data, 'base64');
        console.log(`‚úÖ Extracted image (${imageData.length} bytes, ${(part as any).inlineData.mimeType})`);
        break;
      }
    }

    if (!imageData) {
      console.error('‚ùå No image data found in response');
      console.error('Parts:', JSON.stringify(candidate.content.parts, null, 2));
      throw new Error('No image data in Gemini response');
    }

    // Generate unique filename
    const filename = `user-image-${Date.now()}.png`;

    // Try to upload to GitHub first (permanent, accessible storage)
    const githubUpload = await uploadImageToGitHub(imageData, filename, prompt, username);

    let imageUrl: string;
    let storageProvider: string;

    if (githubUpload) {
      // Use GitHub raw URL for direct image access
      imageUrl = githubUpload.rawUrl;
      storageProvider = 'github';
      console.log(`‚úÖ Image uploaded to GitHub: ${imageUrl}`);
    } else {
      // Fallback: Save to local file system (will have cross-service issues on Railway)
      const outputDir = getUploadsDir();
      await fs.mkdir(outputDir, { recursive: true });
      const imagePath = path.join(outputDir, filename);
      await fs.writeFile(imagePath, imageData);
      console.log(`‚ö†Ô∏è  Image saved locally (fallback): ${imagePath}`);
      console.log(`   Note: Local storage has cross-service access issues on Railway`);

      // This URL will likely 404 on Railway due to cross-service volume isolation
      imageUrl = `${process.env.OMEGA_API_URL || 'https://omegaai.dev'}/uploads/${filename}`;
      storageProvider = 'local';
    }

    // Save metadata to database
    try {
      await saveGeneratedImage({
        userId: userId || 'unknown',
        username,
        toolName: 'generateUserImage',
        prompt,
        model: 'gemini-3-pro-image-preview',
        size: '1024x1024', // Default size for Gemini
        storageUrl: imageUrl,
        storageProvider,
        mimeType: 'image/png',
        bytes: imageData.length,
        status: 'success',
        metadata: {
          filename,
          githubUrl: githubUpload?.githubUrl,
          rawUrl: githubUpload?.rawUrl,
          timestamp: new Date().toISOString(),
        },
        messageId: discordMessageId,
      });
      console.log(`üíæ Image metadata saved to database`);
    } catch (dbError) {
      console.error('‚ö†Ô∏è Failed to save image metadata to database:', dbError);
      // Don't fail the whole operation if DB save fails
    }

    return {
      imageUrl,
      revisedPrompt: prompt, // Gemini doesn't provide a revised prompt like DALL-E
      imageData,
      filename,
    };
  } catch (error) {
    console.error('‚ùå Error generating image:');
    console.error(`   Error Type: ${error instanceof Error ? error.constructor.name : typeof error}`);
    console.error(`   Error Message:`, error instanceof Error ? error.message : String(error));
    console.error(`   Full Error Object:`, JSON.stringify(error, Object.getOwnPropertyNames(error), 2));
    if (error instanceof Error && error.stack) {
      console.error(`   Stack Trace:`, error.stack);
    }
    throw new Error(`Failed to generate image: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}

export const generateUserImageTool = tool({
  description: 'Generate AI-powered images from text prompts using Google Gemini API. Creates high-quality, creative images based on user descriptions. Perfect for creating artwork, illustrations, visual concepts, and creative content. Uses the same model as GeminiComicService for consistency and improved safety. The generated images are automatically uploaded to GitHub for permanent storage and are immediately available as publicly accessible URLs.',
  inputSchema: z.object({
    prompt: z.string().describe('The text description of the image to generate. Be detailed and specific for best results. Example: "A serene mountain landscape at sunset with snow-capped peaks reflecting in a crystal-clear lake"'),
    userId: z.string().optional().describe('User ID of the image creator. Use the current user\'s ID from context if available.'),
    username: z.string().optional().describe('Username of the image creator. Use the current user\'s username from context if available.'),
    discordMessageId: z.string().optional().describe('Discord message ID if this image was requested via Discord.'),
  }),
  execute: async ({ prompt, userId, username, discordMessageId }) => {
    try {
      console.log('üé® Generate User Image: Processing image generation...');
      console.log(`   üìù Prompt: ${prompt}`);
      console.log(`   ü§ñ Model: gemini-3-pro-image-preview (same as GeminiComicService)`);

      const result = await generateImage(prompt, userId, username, discordMessageId);

      console.log(`   ‚úÖ Image generated successfully`);
      console.log(`   üîó URL: ${result.imageUrl}`);

      return {
        imageUrl: result.imageUrl,
        prompt: prompt,
        success: true,
        message: `Image generated successfully! You can view it at: ${result.imageUrl}`,
      };
    } catch (error) {
      console.error('‚ùå Error in generateUserImage tool:');
      console.error(`   Error Type: ${error instanceof Error ? error.constructor.name : typeof error}`);
      console.error(`   Error Message:`, error instanceof Error ? error.message : String(error));
      console.error(`   Full Error Object:`, JSON.stringify(error, Object.getOwnPropertyNames(error), 2));
      if (error instanceof Error && error.stack) {
        console.error(`   Stack Trace:`, error.stack);
      }

      // Save failed attempt to database
      try {
        await saveGeneratedImage({
          userId: userId || 'unknown',
          username,
          toolName: 'generateUserImage',
          prompt,
          model: 'gemini-3-pro-image-preview',
          storageUrl: '', // No URL on failure
          status: 'failed',
          error: error instanceof Error ? error.message : 'Unknown error',
          metadata: {
            errorType: error instanceof Error ? error.constructor.name : typeof error,
            timestamp: new Date().toISOString(),
          },
          messageId: discordMessageId,
        });
        console.log(`üíæ Failed image generation logged to database`);
      } catch (dbError) {
        console.error('‚ö†Ô∏è Failed to log error to database:', dbError);
      }

      return {
        error: error instanceof Error ? error.message : 'Failed to generate image',
        success: false,
        message: 'Failed to generate image. Please try again with a different prompt.',
      };
    }
  },
});
