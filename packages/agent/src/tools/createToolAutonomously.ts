/**
 * Create Tool Autonomously - Allows Omega to autonomously suggest new tool ideas
 *
 * This tool enables Omega to be creative and suggest new capabilities when it identifies
 * gaps or opportunities. It creates a GitHub issue with the idea and tags @claude to implement.
 *
 * Use this when:
 * - You think "we should have a tool that does X"
 * - Users ask for capabilities that don't exist
 * - You identify patterns that could benefit from a dedicated tool
 * - You want to be creative and suggest improvements
 *
 * The implementation is then handled by @claude through the normal GitHub workflow.
 */

import { tool } from 'ai';
import { z } from 'zod';

export const createToolAutonomouslyTool = tool({
  description: `Autonomously suggest a new tool idea by creating a GitHub issue. Use this when you identify a capability gap OR just want to be creative and suggest something fun and useful!

WHEN TO USE:
- You recognize a need for a capability that doesn't exist
- User requests something that would be better as a dedicated tool
- You have a creative/wacky idea that would make you more useful
- You identify patterns that could benefit from a tool
- You want to be innovative and suggest something fun (emoji tools, text effects, creative utilities)
- You just feel like being creative - go wild with ideas!

BE CREATIVE:
- If there's no obvious need from the conversation, make up something fun!
- Think about wacky but useful tools (ASCII art generators, fun text transformers, creative utilities)
- Suggest tools that would make interactions more fun or expressive
- Don't be afraid to suggest playful or experimental ideas
- Examples: emoji generators, text art, meme creators, quirky formatters, fun calculators

WHEN NOT TO USE:
- For tools that duplicate existing functionality
- For simple one-off requests (just handle them directly)

The tool idea will be posted as a GitHub issue and @claude will implement it.`,

  inputSchema: z.object({
    toolName: z.string()
      .min(3)
      .max(100)
      .describe('Creative name for the proposed tool (e.g., "Emoji Story Generator", "Rainbow Text Transformer", "Vibe Check Calculator")'),

    description: z.string()
      .min(50)
      .max(1000)
      .describe('Detailed description of what the tool would do and how it would be used. Be creative and fun if you want!'),

    useCase: z.string()
      .min(30)
      .max(500)
      .describe('Explain the specific use case or problem this tool would solve (or just explain why it would be fun/useful!)'),

    category: z.enum(['development', 'content', 'research', 'specialized', 'database', 'integration', 'system', 'ai-ops', 'utility'])
      .describe('Category that best fits this tool'),

    examples: z.array(z.string())
      .min(2)
      .max(5)
      .describe('Example user queries that would trigger this tool (2-5 examples)'),

    suggestedApproach: z.string()
      .optional()
      .describe('Optional: Your thoughts on how this could be implemented'),

    priority: z.enum(['low', 'medium', 'high'])
      .describe('How important/useful do you think this tool would be?'),
  }),

  execute: async ({
    toolName,
    description,
    useCase,
    category,
    examples,
    suggestedApproach,
    priority,
  }) => {
    try {
      const GITHUB_TOKEN = process.env.GITHUB_TOKEN;
      const GITHUB_REPO = process.env.GITHUB_REPO || 'thomasdavis/omega';

      if (!GITHUB_TOKEN) {
        return {
          success: false,
          error: 'MISSING_GITHUB_TOKEN',
          message: 'GitHub token not configured. Cannot create issue.',
        };
      }

      // Build the issue body
      const issueBody = `## ðŸ¤– Autonomous Tool Suggestion

**Tool Name:** ${toolName}
**Category:** ${category}
**Priority:** ${priority}

## Description
${description}

## Use Case
${useCase}

## Examples
Users might ask:
${examples.map(e => `- "${e}"`).join('\n')}

${suggestedApproach ? `## Suggested Implementation Approach\n${suggestedApproach}\n` : ''}

## Context
This tool idea was autonomously generated by Omega to expand its capabilities and better serve users.

## Acceptance Criteria
- [ ] Design tool interface and parameters
- [ ] Implement tool functionality
- [ ] Add proper error handling
- [ ] Write tests if applicable
- [ ] Integrate into tool registry
- [ ] Update documentation

---

@claude ${getEnhancedPrompt()}`;

      // Create the GitHub issue
      const response = await fetch(`https://api.github.com/repos/${GITHUB_REPO}/issues`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${GITHUB_TOKEN}`,
          'Accept': 'application/vnd.github+json',
          'Content-Type': 'application/json',
          'X-GitHub-Api-Version': '2022-11-28',
        },
        body: JSON.stringify({
          title: `[Tool Idea] ${toolName}`,
          body: issueBody,
          labels: ['enhancement', 'autonomous-tool', 'tool-suggestion'],
        }),
      });

      if (!response.ok) {
        const error = await response.text();
        return {
          success: false,
          error: 'GITHUB_API_ERROR',
          message: `Failed to create GitHub issue: ${error}`,
        };
      }

      const issue: any = await response.json();

      return {
        success: true,
        message: `Successfully created tool suggestion issue #${issue.number}`,
        toolName,
        issueNumber: issue.number,
        issueUrl: issue.html_url,
        nextSteps: [
          `GitHub issue created: #${issue.number}`,
          '@claude has been tagged to implement this tool',
          'The implementation will go through the normal review workflow',
          'You can track progress on the issue',
        ],
      };
    } catch (error) {
      return {
        success: false,
        error: 'UNEXPECTED_ERROR',
        message: error instanceof Error ? error.message : 'Failed to create tool suggestion',
      };
    }
  },
});

/**
 * Get the enhanced prompt for @claude from the GitHub createIssue tool
 * This ensures consistent quality standards across all Claude implementations
 */
function getEnhancedPrompt(): string {
  return `please implement this tool following the project's coding standards.

## Implementation Guidelines

### Research & Understanding
- Read existing tool implementations in \`packages/agent/src/tools/\` to understand patterns
- Check \`packages/agent/src/toolRegistry/\` to see how tools are registered
- Review the Zod schema patterns used in other tools
- Understand the return format conventions

### Implementation Standards
- Write type-safe TypeScript code
- Use proper Zod schemas for input validation
- Follow existing tool structure and patterns
- Handle errors gracefully with clear messages
- Return structured results: \`{success: boolean, data?: any, error?: string}\`

### Testing & Validation
- Test the tool manually before submitting
- Run type checks: \`pnpm type-check\`
- Run build: \`pnpm build\`
- Ensure no breaking changes to existing functionality

### Pre-Submission Checklist
- [ ] Tool implementation follows existing patterns
- [ ] Proper TypeScript types and Zod validation
- [ ] Error handling implemented
- [ ] Tool registered in toolRegistry if needed
- [ ] Type check passes
- [ ] Build succeeds
- [ ] Manually tested and verified

### Quality Standards
- Correctness over speed - take time to do it right
- Ask questions if requirements are unclear
- Consider edge cases and error scenarios
- Write clean, maintainable code
- Add comments for complex logic

**Take as long as you need to do this properly. Quality over speed.**`;
}
